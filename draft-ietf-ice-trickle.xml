<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<rfc category='std' ipr='trust200902'
     docName='draft-ietf-ice-trickle-18'>

<?rfc toc='yes' ?>
<?rfc symrefs='yes' ?>
<?rfc sortrefs='yes'?>
<?rfc iprnotified='no' ?>
<?rfc strict='yes' ?>
<?rfc compact='yes' ?>
  <front>

    <title abbrev='Trickle ICE'>
        Trickle ICE: Incremental Provisioning of Candidates for the Interactive 
        Connectivity Establishment (ICE) Protocol
    </title>
    <author initials='E.' surname='Ivov'
            fullname='Emil Ivov'>
      <organization abbrev='Atlassian'>Atlassian</organization>
      <address>
        <postal>
          <street>303 Colorado Street, #1600</street>
          <city>Austin</city>
          <region>TX</region>
          <code>78701</code>
          <country>USA</country>
        </postal>
        <phone>+1-512-640-3000</phone>
        <email>eivov@atlassian.com</email>
      </address>
    </author>
    <author fullname="Eric Rescorla" initials="E.K." surname="Rescorla">
      <organization>RTFM, Inc.</organization>
      <address>
        <postal>
          <street>2064 Edgewood Drive</street>
          <city>Palo Alto</city>
          <region>CA</region>
          <code>94303</code>
          <country>USA</country>
        </postal>
        <phone>+1 650 678 2350</phone>
        <email>ekr@rtfm.com</email>
      </address>
    </author>
    <author fullname="Justin Uberti" initials="J." surname="Uberti">
      <organization>Google</organization>
      <address>
        <postal>
          <street>747 6th St S</street>
          <city>Kirkland</city>
          <region>WA</region>
          <code>98033</code>
          <country>USA</country>
        </postal>
        <phone>+1 857 288 8888</phone>
        <email>justin@uberti.name</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization>Mozilla</organization>
      <address>
        <postal>
          <street>P.O. Box 787</street>
          <city>Parker</city>
          <region>CO</region>
          <code>80134</code>
          <country>USA</country>
        </postal>
        <phone>+1 720 256 6756</phone>
        <email>stpeter@mozilla.com</email>
        <uri>https://www.mozilla.com/</uri>
      </address>
    </author>
    <date />
    <abstract>
      <t>
        This document describes "Trickle ICE", an extension to the Interactive
        Connectivity Establishment (ICE) protocol that enables ICE agents
        to send and receive candidates incrementally rather than
        exchanging complete lists. With such incremental provisioning,
        ICE agents can begin connectivity checks while they are still
        gathering candidates and considerably shorten the time necessary
        for ICE processing to complete.
      </t>
    </abstract>
  </front>
  <middle>
    <section title='Introduction'>
      <t>
        The Interactive Connectivity Establishment (ICE) protocol
        <xref target="rfc5245bis"/> describes mechanisms for gathering
        candidates, prioritizing them, choosing default ones, exchanging
        them with a remote party, pairing them, and ordering the candidate pairs into
        check lists. Once all of these actions have been completed (and only
        then), the parties can begin a phase of connectivity
        checks and eventually select the pair of candidates that will be
        used in a media session or for a given media stream.
      </t>
      <t>
        Although the sequence described above has the advantage of being 
        relatively straightforward to implement and debug once deployed, 
        it can also take quite a bit of time to complete.
        Candidate gathering often involves things like querying
        <xref target="RFC5389">STUN</xref> servers
        and allocating relayed candidates at
        <xref target="RFC5766">TURN</xref> servers. All of these actions can
        be delayed for a noticeable amount of time; although they can be
        run in parallel, they still need to respect the pacing
        requirements from <xref target="rfc5245bis"/>, which is likely to
        delay them even further. Some or all of these actions also
        need be completed by the responder. Both agents would
        next perform connectivity checks and only then would they be
        ready to begin streaming media.
      </t>
      <t>
        These factors can lead to relatively lengthy session
        establishment times and thus to a degraded user experience.
      </t>
      <t>
        This document defines a supplementary mode of
        operation for ICE implementations, known as "Trickle ICE",
        in which candidates can be exchanged incrementally. This enables
        ICE agents to exchange candidates as soon as an ICE session
        has been initiated and a candidate has become available. Connectivity checks for a media
        stream can also start as soon as the first candidates for that
        stream become available.
      </t>
      <t>
        Trickle ICE can reduce session establishment times in cases
        where connectivity is confirmed for the first exchanged
        candidates (e.g., where candidates for one of the agents
        are directly reachable from the second agent, such as 
        candidates at a media relay). Even when this is
        not the case, performing candidate gathering for both agents and
        connectivity checks in parallel can considerably
        shorten ICE processing times.
      </t>
      <t>
        It is worth noting that there is quite a bit of operational 
        experience with the Trickle ICE technique, going back as far as
        2005 (when the XMPP Jingle extension defined a "dribble mode" as
        specified in <xref target="XEP-0176"/>); this document incorporates 
        feedback from those who have implemented and deployed the technique.
      </t>
      <t>
        In addition to the basics of Trickle ICE, this document also
        describes how to discover support for Trickle ICE,
        how regular ICE processing needs to be modified when
        forming and updating check lists, and how Trickle ICE
        implementations interoperate with agents that only
        implement regular ICE processing as defined in
        <xref target="rfc5245bis"/>.  Unless otherwise noted herein,
        the procedures defined in <xref target="rfc5245bis"/> apply
        to Trickle ICE agents as well.
      </t>
      <t>
        This specification does not define the usage of Trickle ICE with any
        specific signaling protocol (however, see 
        <xref target="I-D.ietf-mmusic-trickle-ice-sip"/> for usage with SIP
        <xref target='RFC3261'/> 
        and <xref target='XEP-0176'/> for usage with XMPP <xref target='RFC6120'/>).
        Similarly, it does not define Trickle ICE in
        terms of the Session Description Protocol (SDP) <xref target='RFC4566'/>
        or the offer/answer model <xref target='RFC3264'/> because 
        the technique can be and already is used in application protocols 
        that are not tied to SDP or to offer/answer semantics.
        However, because SDP and the offer/answer model are familiar to most
        readers of this specification, some examples in this document use those
        particulars in order to explain the underlying concepts.
      </t>
      <t>
        The following diagram illustrates a successful Trickle ICE exchange with a
        signaling protocol that follows the offer/answer model:
      </t>
      <figure title="Flow" anchor="fig-flow">
        <artwork>
<![CDATA[
        Alice                                            Bob
          |                     Offer                     |
          |---------------------------------------------->|
          |            Additional Candidates              |
          |---------------------------------------------->|
          |                     Answer                    |
          |<----------------------------------------------|
          |            Additional Candidates              |
          |<----------------------------------------------|
          | Additional Candidates and Connectivity Checks |
          |<--------------------------------------------->|
          |<========== CONNECTION ESTABLISHED ===========>|

]]>
        </artwork>
      </figure>
    </section>
    <section title="Terminology">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
        NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
        "OPTIONAL" in this document are to be interpreted as described
        in <xref target="RFC2119"/>.
      </t>
      <t>
        This specification makes use of all terminology defined 
        for Interactive Connectivity Establishment in
        <xref target="rfc5245bis"/>. In addition, it defines the following terms:
      </t>
      <t>
        <list style="hanging">
          <t hangText="Full Trickle:">
            The typical mode of operation for Trickle ICE agents, in which
            the initial ICE description can include any number of candidates (even
            zero candidates) and does not need to include a full generation
            of candidates as in half trickle.
          </t>
          <t hangText="Generation:">
            All of the candidates conveyed within an ICE session; these are the
            candidates that are associated with a specific local/remote Username
            Fragment and Password combination (which will change on ICE restart, 
            if any occurs).
          </t>
          <t hangText="Half Trickle:">
            A Trickle ICE mode of operation where the initiator gathers
            a full generation of candidates strictly before creating
            and conveying the initial ICE description. Once conveyed, 
            this candidate information can be
            processed by regular ICE agents, which do not require support
            for this specification. It also allows Trickle ICE capable
            responders to still gather candidates and perform
            connectivity checks in a non-blocking way, thus roughly
            providing "half" the advantages of Trickle ICE. The mechanism
            is mostly meant for use in cases where the responder's support for Trickle
            ICE cannot be confirmed prior to conveying the initial ICE description.
          </t>
          <t hangText="ICE Description:">
            Any session-related (as opposed to candidate-related) attributes 
            required to configure an ICE agent. These include but are not 
            limited to the username fragment, password, and other attributes.
          </t>
          <t hangText="Trickled Candidates:">
            Candidates that a Trickle ICE agent conveys after conveying the initial 
            ICE description or responding to the initial ICE description, but within 
            the same ICE session.  Trickled candidates can be conveyed in 
            parallel with candidate gathering and connectivity checks.
          </t>
          <t hangText="Trickling:">
            The act of conveying trickled candidates.
          </t>
        </list>
      </t>
    </section>
    <section title='Determining Support for Trickle ICE' anchor="disco">
      <t>
        To fully support Trickle ICE, applications
        SHOULD incorporate one of the following mechanisms to enable implementations
        to determine whether Trickle ICE is supported:
      </t>
      <t>
        <list style='numbers'>
          <t>
            Provide a capabilities discovery method so that agents can verify 
            support of Trickle ICE prior to initiating a session (XMPP's
            <xref target="XEP-0030">Service Discovery</xref> is 
            one such mechanism).
          </t>
          <t>
            Make support for Trickle ICE mandatory so that user agents
            can assume support.
          </t>
        </list>
      </t>
      <t>
        If an application protocol does not provide a method of determining
        ahead of time whether Trickle ICE is supported, agents can make use of 
        the half trickle procedure described in <xref target="half-trickle"/>.
      </t>
      <t>
        Prior to conveying the initial ICE description, agents using signaling protocols
        that support capabilities discovery can attempt to verify whether or 
        not the remote party supports Trickle ICE. If an agent determines 
        that the remote party does not support Trickle ICE, it MUST fall back 
        to using regular ICE or abandon the entire session.
      </t>
      <t>
        Even if a signaling protocol does not include a capabilities discovery 
        method, a user agent can provide an indication within the ICE description 
        that it supports Trickle ICE by communicating an ICE option of 'trickle'.  
        This token MUST be provided either at the session level or, if at the media 
        stream level, for every media stream (an agent MUST NOT specify Trickle ICE 
        support for some media streams but not others).

        NOTE: The encoding of the 'trickle' ICE option, and the message(s) used to 
        carry it to the peer, are protocol specific.  The encoding for the Session 
        Description Protocol (SDP) <xref target='RFC4566'/> is defined in
        <xref target='I-D.ietf-mmusic-trickle-ice-sip'/>.
      </t>
      <t>
        Dedicated discovery semantics and half trickle are needed
        only prior to session initiation. After a session is established
        and Trickle ICE support is confirmed for both parties, either
        agent can use full trickle for subsequent exchanges.
      </t>
    </section>
    <section title='Conveying the Initial ICE Description' anchor="initial">
      <t>
        An initiator can start gathering candidates as soon as it has an
        indication that communication is imminent (e.g., a user interface
        cue or an explicit request to initiate a session). Unlike in
        regular ICE, in Trickle ICE implementations do not need to
        gather candidates in a blocking manner. Therefore, unless half
        trickle is being used, the user experience is improved if the 
        initiator generates and transmits their initial ICE description 
        as early as possible (thus enabling the remote party to start 
        gathering and trickling candidates).
      </t>
      <t>
        An initiator MAY include any mix of candidates when conveying
        the initial ICE description. This includes the possibility of conveying 
        all the candidates the initiator plans to use
        (as in half trickle mode), conveying only a 
        publicly-reachable IP address (e.g., a candidate at a media 
        relay that is known to not be behind a firewall), or conveying 
        no candidates at all (in which case the initiator can obtain the 
        responder's initial candidate list sooner and the responder can begin 
        candidate gathering more quickly).
      </t>
      <t>
        Methods for calculating priorities and foundations, as well as 
        determining redundancy of candidates, work just as with regular
        ICE (with the exception of pruning of duplicate peer reflexive
        candidates as described under <xref target='check.lists'/>).
      </t>
    </section>
    <section title='Responder Procedures' >
      <t>
        When a responder receives the initial ICE description, it will first check if
        the ICE description or initiator indicates support for Trickle ICE as explained in
        <xref target="disco"/>. If this is not the case, the responder MUST
        process the initial ICE description according to regular ICE procedures 
        <xref target="rfc5245bis"/> (or, if no ICE support is detected at all,
        according to relevant processing rules for the underlying signaling 
        protocol, such as offer/answer processing rules <xref target="RFC3264"/>).
      </t>
      <t>
        If support for Trickle ICE is
        confirmed, a responder will automatically assume support for
        regular ICE as well. Specifically, 
        the rules from <xref target="rfc5245bis"/> would imply that ICE 
        itself is not supported if the initial ICE description includes no candidates;
        however, such a conclusion is not warranted if the 
        responder can confirm that the initiator supports Trickle ICE; in this case,
        fallback to non-ICE processing rules is not necessary.
      </t>
      <t>
        If the initial ICE description indicates support for Trickle ICE, the responder
        will determine its role and start gathering and prioritizing
        candidates; while doing so, it will also respond by conveying
        its own ICE description, so that both the initiator and the responder can start forming check
        lists and begin connectivity checks.
      </t>
      <section title="Conveying the Initial Response">
        <t>
          A responder can respond to the initial ICE description at any point while
          gathering candidates. Here again the ICE description MAY contain any set of
          candidates, including all candidates or no candidates. (The
          benefit of including no candidates is to convey the ICE description as 
          quickly as possible, so that both parties can consider the 
          overall session to be under active negotiation as soon as 
          possible.) 
        </t>
        <t>
          As noted in <xref target="disco"/>, in application protocols that use 
          SDP the responder's ICE description can indicate support for Trickle ICE 
          by including a token of "trickle" in the ice-options attribute.
        </t>
      </section>
      <section title="Forming Check Lists and Beginning Connectivity
                      Checks" anchor="check.lists">
        <t>
          As soon as the agents have
          obtained local and remote candidates, both agents begin
          forming candidate pairs, computing candidate pair priorities,
          ordering candidate pairs, pruning duplicate pairs, and
          creating check lists according to regular ICE procedures
          <xref target="rfc5245bis"/>. 
        </t>
        <t>
          According to those procedures, in order for candidate pairing 
          to be possible and for duplicate candidates to be pruned, the 
          candidates would need to be provided in the relevant ICE descriptions.
          By contrast, under Trickle ICE check lists can be empty until 
          candidates are conveyed or received. Therefore Trickle ICE agents 
          handle check lists and candidate pairing in a slightly different
          way than regular ICE agents: the agents still form the check lists, but 
          they populate the check lists only after they actually have the candidate 
          pairs.  Every check list is initially placed in the Running state, even
          if there are not yet any candidate pairs in the check list.
        </t>
        <t>
          A Trickle ICE agent initially considers all candidate pairs in all check lists to be
          frozen.  It then inspects the first check list and attempts to 
          unfreeze all candidate pairs it has received so far that belong to the 
          first component on the first media stream (i.e., the first media
          stream that was reported to the ICE implementation from the
          using application). If that first component of the first media stream
          does not contain candidates for one or more of the currently known 
          pair foundations, and if candidate pairs already exist for that 
          foundation in one of the following components or media streams, then 
          the agent unfreezes the first of those candidate pairs.
        </t>
        <t>
          With regard to pruning of duplicate candidate pairs, a Trickle ICE
          agent SHOULD follow a policy of keeping the higher priority
          candidate unless it is peer reflexive.
        </t>
      </section>
    </section>
    <section title="Initiator Procedures">
      <t>
        When processing the initial ICE description from a responder, the initiator follows regular ICE
        procedures to determine its role, after which it
        forms check lists (as described in <xref target="check.lists"/>)
        and begins connectivity checks.
      </t>
    </section>
    <section title='Performing Connectivity Checks' anchor='checks'>
      <t>
        For the most part, Trickle ICE agents perform connectivity
        checks following regular ICE procedures. However, the fact that
        gathering and communicating candidates is asynchronous 
        in Trickle ICE imposes several changes.
      </t>
      <t>
        First, the ICE specification <xref target='rfc5245bis'/>, Section 7.2.5.3.3, 
        requires that agents update check lists and timer states upon 
        completing a connectivity check transaction. During such an 
        update, regular ICE agents would set the state of a check list 
        to Failed if both of the following two conditions are satisfied:
      </t>
      <t>
        <list style="symbols">
          <t>
            all of the pairs in the check list are either in the
            Failed state or Succeeded state; and
          </t>
          <t>
            there is not a pair in the valid list for each component 
            of the media stream.
          </t>
        </list>
      </t>
      <t>
        With Trickle ICE, the above situation would often occur when
        candidate gathering and trickling are still in progress, even
        though it is quite possible that future checks will succeed. For
        this reason, Trickle ICE agents add the following conditions to
        the above list:
      </t>
      <t>
        <list style="symbols">
          <t>
            all candidate gathering has completed and the agent
            is not expecting to discover any new local candidates;
          </t>
          <t>
            the remote agent has conveyed an end-of-candidates indication
            for that check list as described in
            <xref target="end-of-candidates"/>.
          </t>
        </list>
      </t>
      <t>
        Second, a Trickle ICE agent will form check lists even if a given
        check list does not yet have any candidates in it; in accordance with 
        the ICE specification <xref target='rfc5245bis'/>, Section 6.1.2.1, a 
        Trickle ICE agent considers an empty check list to be in the Running state.
      </t>
      <t>
        Third, in accordance with <xref target='cand-insert'/>, when inserting a new 
        candidate pair into an empty check list, the agent sets the pair to a 
        state of Waiting.
      </t>
    </section>
    <section title='Discovering and Conveying Additional Local Candidates'
             anchor="send-trickling">
      <t>
        After candidate information has been conveyed, agents will most
        likely continue discovering new local candidates as STUN, TURN,
        and other non-host candidate gathering mechanisms begin to
        yield results. Whenever an agent discovers such a new candidate
        it will compute its priority, type, foundation and component ID
        according to regular ICE procedures.
      </t>
      <t>
        The new candidate is then checked for redundancy against the
        existing list of local candidates. If its transport address and
        base match those of an existing candidate, it will be considered
        redundant and will be ignored. This would often happen for
        server reflexive candidates that match the host addresses they
        were obtained from (e.g., when the latter are public IPv4
        addresses). Contrary to regular ICE, Trickle ICE agents will
        consider the new candidate redundant regardless of its priority.
      </t>
      <t>
        Next the agent "trickles" the newly discovered
        candidate(s) to the remote agent. The actual delivery of the new
        candidates is handled by a signaling protocol such as SIP or XMPP.
        Trickle ICE imposes no restrictions on the way this is done 
        (e.g., some applications may
        choose not to trickle updates for server reflexive
        candidates and instead rely on the discovery of peer reflexive ones).
      </t>
      <t>
        When candidates are trickled, the signaling protocol MUST deliver each 
        candidate (and any end-of-candidates indication as described in
        <xref target='end-of-candidates'/>) to the receiving Trickle ICE implementation not more than once 
        and in the same order it was conveyed. If the signaling protocol 
        provides any candidate retransmissions, they need to be hidden 
        from the ICE implementation.
      </t>
      <t>
        Also, candidate trickling needs to be correlated to a specific
        ICE session, so that if there is an ICE restart, any
        delayed updates for a previous session can be recognized as such
        and ignored by the receiving party.  For example, applications
        that choose to signal candidates via SDP may include a Username
        Fragment value in the corresponding a=candidate line, such as:
        <figure>
          <artwork>
<![CDATA[
  a=candidate:1 1 UDP 2130706431 2001:db8::1 5000 typ host ufrag 8hhY
]]>
          </artwork>
        </figure>
        Or as another example, WebRTC implementations may include a Username
        Fragment in the JavaScript objects that represent candidates.
      </t>
      <t>
        Note: The signaling protocol needs to provide a mechanism for both
        parties to indicate and agree on the ICE session in force
        (as identified by the Username Fragment and Password combination)
        so that they have a consistent view of which candidates are
        to be paired.  This is especially important in the case of ICE
        restarts (see <xref target='subsequent'/>).
      </t>
      <t>
        Once the candidate has been conveyed to the remote party, the agent
        checks if any remote candidates are currently known for this
        same stream and component. If not, the new candidate will
        simply be added to the list of local candidates.
      </t>
      <t>
        Otherwise, if the agent has already learned of one or more
        remote candidates for this stream and component, it will begin
        pairing the new local candidates with them and adding the pairs
        to the existing check lists according to their priority.
      </t>
      <t>
        Note: A Trickle ICE agent MUST NOT pair a local candidate until it
        has been trickled to the remote agent.
      </t>
      <section title='Pairing Newly Learned Candidates and Updating
                      Check Lists' anchor="cand-pairing">
        <t>
          Forming candidate pairs works as described in
          the ICE specification <xref target='rfc5245bis'/>. 
          However, actually adding the new pair to
          a check list happens according to the rules
          described below.
        </t>
        <t>
          If the check list where the pair is to be added already
          contains the maximum number of candidate pairs (100 by default
          as per <xref target="rfc5245bis"/>), the new pair is discarded.
        </t>
        <t>
          If the new pair's local candidate is server reflexive, the
          server reflexive candidate MUST be replaced by its base before
          adding the pair to the list. 
        </t>
        <t>
          Once this is done, the agent examines the check list looking for 
          another pair that would be redundant with the new one. If such a 
          pair exists and the type of its remote candidate is not peer 
          reflexive, the pair with the higher priority is kept and the one 
          with the lower priority is discarded. If, on the other hand, the 
          type of the remote candidate in the pre-existing pair is peer 
          reflexive, the agent MUST replace it with the newly formed pair 
          (regardless of their respective priorities); this is done 
          by setting the priority of the new candidate to the priority of the 
          pre-existing candidate and then re-sorting the check list.
        </t>
        <t>
          For all other pairs, including those with a server reflexive
          local candidate that were not found to be redundant, the rules 
          specified in the following section apply.
        </t>
        <section title='Inserting a New Pair in a Check List' anchor="      
              cand-insert">
          <t>
            Consider the following tabular representation of all check lists in 
            an agent (note that initially for one of the foundations, i.e., f5, 
            there are no candidate pairs): 
          </t>
          <t>
            <figure title="Example of Check List State" anchor="fig-checklist-0">
              <artwork>
<![CDATA[
+-----------------+------+------+------+------+------+
|                 |  f1  |  f2  |  f3  |  f4  |  f5  |
+-----------------+------+------+------+------+------+
| m1 (Audio.RTP)  |  F   |  F   |  F   |      |      |
+-----------------+------+------+------+------+------+
| m2 (Audio.RTCP) |  F   |  F   |  F   |  F   |      |
+-----------------+------+------+------+------+------+
| m3 (Video.RTP)  |  F   |      |      |      |      |
+-----------------+------+------+------+------+------+
| m4 (Video.RTCP) |  F   |      |      |      |      |
+-----------------+------+------+------+------+------+
]]>
              </artwork>
            </figure>
          </t>
          <t>
            Each row in the table represents a component for a given media
            stream (e.g., m1 and m2 might be the RTP and RTCP components
            for audio). Each column represents one foundation. Each cell 
            represents one candidate pair. In the foregoing table, "F" stands 
            for "frozen"; in the tables below, "W" stands for "waiting" and
            "S" stands for "succeeded".
          </t>
          <t>
            When an agent commences ICE processing,
            in accordance with Section 6.1.2.6 of
            <xref target="rfc5245bis"/> 
            it will unfreeze (i.e., place in the Waiting 
            state) the topmost candidate pair in every column (i.e., the
            pair with the lowest component ID).  This state is shown in
            the following table, with candidate pairs in the Waiting state
            marked by "W".
          </t>
          <t>
            <figure title="Initial Check List State" anchor="fig-checklist-1">
              <artwork>
<![CDATA[
+-----------------+------+------+------+------+------+
|                 |  f1  |  f2  |  f3  |  f4  |  f5  |
+-----------------+------+------+------+------+------+
| m1 (Audio.RTP)  |  W   |  W   |  W   |      |      |
+-----------------+------+------+------+------+------+
| m2 (Audio.RTCP) |  F   |  F   |  F   |  W   |      |
+-----------------+------+------+------+------+------+
| m3 (Video.RTP)  |  F   |      |      |      |      |
+-----------------+------+------+------+------+------+
| m4 (Video.RTCP) |  F   |      |      |      |      |
+-----------------+------+------+------+------+------+
]]>
              </artwork>
            </figure>
          </t>
          <t>
            Then, as the checks proceed (see Section 7.2.5.4 of
            <xref target="rfc5245bis"/>), for each pair 
            that enters the Succeeded state (denoted here by "S"),
            the agent will unfreeze all pairs for all media streams with the same
            foundation (e.g., if the pair in column 1, row 1 succeeds then
            the agent will unfreeze the pair in column 1, rows 2, 3, and 4). 
          </t>
          <t>
            <figure title="Check List State with Unfrozen Media Stream" anchor="fig-checklist-3">
              <artwork>
<![CDATA[
+-----------------+------+------+------+------+------+
|                 |  f1  |  f2  |  f3  |  f4  |  f5  |
+-----------------+------+------+------+------+------+
| m1 (Audio.RTP)  |  S   |  W   |  W   |      |      |
+-----------------+------+------+------+------+------+
| m2 (Audio.RTCP) |  W   |  F   |  F   |  W   |      |
+-----------------+------+------+------+------+------+
| m3 (Video.RTP)  |  W   |      |      |      |  W   |
+-----------------+------+------+------+------+------+
| m4 (Video.RTCP) |  W   |      |      |      |  F   |
+-----------------+------+------+------+------+------+
]]>
              </artwork>
            </figure>
          </t>
          <t>
            Trickle ICE preserves all of these rules as they apply to what we might 
            call "static" check list sets. This implies that if, for 
            some reason, a Trickle agent were to begin connectivity checks with all 
            of its pairs already present, the way that pair states change 
            is indistinguishable from that of a regular ICE agent. 
          </t>
          <t>
            Of course, the major difference with Trickle ICE is that check list 
            sets can be dynamically updated because candidates can 
            arrive after connectivity checks have started. When this happens, an 
            agent sets the state of the newly formed pair as described below.
          </t>
          <t>
            Case 1: If the newly formed pair is the topmost pair in its column (i.e.
            the topmost pair among all the check lists for this foundation), set 
            the state to Waiting (e.g., this would be the case if the newly formed pair 
            were placed in column 5, row 1).
          </t>
          <t>
            <figure title="Check List State with Newly Formed Pair, Case 1" anchor="fig-checklist-4">
              <artwork>
<![CDATA[
+-----------------+------+------+------+------+------+
|                 |  f1  |  f2  |  f3  |  f4  |  f5  |
+-----------------+------+------+------+------+------+
| m1 (Audio.RTP)  |  S   |  W   |  W   |      |  W   |
+-----------------+------+------+------+------+------+
| m2 (Audio.RTCP) |  W   |  F   |  F   |  W   |      |
+-----------------+------+------+------+------+------+
| m3 (Video.RTP)  |  W   |      |      |      |      |
+-----------------+------+------+------+------+------+
| m4 (Video.RTCP) |  W   |      |      |      |      |
+-----------------+------+------+------+------+------+
]]>
              </artwork>
            </figure>
          </t>
          <t> 
            Case 2: If the pair immediately above the newly formed pair in its column 
            is in the Succeeded state, set the state to Waiting (e.g., this would be 
            the case if the pair in column 5, row 1 succeeded and the newly formed pair 
            were placed in column 5, row 2);
          </t>
          <t>
            <figure title="Check List State with Newly Formed Pair, Case 2" anchor="fig-checklist-5">
              <artwork>
<![CDATA[
+-----------------+------+------+------+------+------+
|                 |  f1  |  f2  |  f3  |  f4  |  f5  |
+-----------------+------+------+------+------+------+
| m1 (Audio.RTP)  |  S   |  W   |  W   |      |  S   |
+-----------------+------+------+------+------+------+
| m2 (Audio.RTCP) |  W   |  F   |  F   |  W   |  W   |
+-----------------+------+------+------+------+------+
| m3 (Video.RTP)  |  W   |      |      |      |      |
+-----------------+------+------+------+------+------+
| m4 (Video.RTCP) |  W   |      |      |      |      |
+-----------------+------+------+------+------+------+
]]>
              </artwork>
            </figure>
          </t>
          <t>
            Case 3: If there is at least one Succeeded pair in its column above the 
            row of the newly formed pair, set the state to Waiting (e.g., this would 
            be the case if the pair in column 5, row 1 succeeded and two newly formed 
            pairs were placed in column 5, rows 3 and 4).
          </t>
          <t>
            <figure title="Check List State with Newly Formed Pair, Case 3" anchor="fig-checklist-6">
              <artwork>
<![CDATA[
+-----------------+------+------+------+------+------+
|                 |  f1  |  f2  |  f3  |  f4  |  f5  |
+-----------------+------+------+------+------+------+
| m1 (Audio.RTP)  |  S   |  W   |  W   |      |  S   |
+-----------------+------+------+------+------+------+
| m2 (Audio.RTCP) |  W   |  F   |  F   |  W   |  W   |
+-----------------+------+------+------+------+------+
| m3 (Video.RTP)  |  W   |      |      |      |  W   |
+-----------------+------+------+------+------+------+
| m4 (Video.RTCP) |  W   |      |      |      |  W   |
+-----------------+------+------+------+------+------+
]]>
              </artwork>
            </figure>
          </t>
          <t>
            Case 4: In all other cases, set the state to Frozen.
          </t>
        </section>
      </section>
      <section title='Announcing End of Candidates'
             anchor="end-of-candidates">
      <t>
        Once all candidate gathering is completed or expires for an
        ICE session associated with a specific media stream, the agent will generate an
        "end-of-candidates" indication for that session and convey it to
        the remote agent via the signaling channel. Although the exact form of
        the indication depends on the application protocol, the indication
        MUST specify the generation (Username Fragment and Password combination) so that an agent
        can correlate the end-of-candidates indication with a particular ICE
        session. The indication can be conveyed in the following ways:
        <list style='symbols'>
          <t>As part of an initiation request (which would typically be the case with 
             the initial ICE description for half trickle)</t>
          <t>Along with the last candidate an agent can send for a stream</t>
          <t>As a standalone notification (e.g., after STUN Binding requests 
             or TURN Allocate requests to a server time out and the agent 
             is no longer actively gathering candidates)</t>
        </list>
      </t>
      <t>
        Conveying an end-of-candidates indication in a timely manner is important 
        in order to avoid ambiguities and speed up the conclusion of ICE processing. 
        In particular: 
        <list style='symbols'>
          <t>
            A controlled Trickle ICE agent SHOULD convey an end-of-candidates 
            indication after it has completed gathering for a media stream, 
            unless ICE processing terminates before the agent has had a chance 
            to complete gathering. 
          </t>
          <t>
            A controlling agent MAY conclude ICE processing prior to conveying 
            end-of-candidates indications for all streams.  However, it is 
            RECOMMENDED for a controlling agent to convey end-of-candidates 
            indications whenever possible for the sake of consistency and to 
            keep middleboxes and controlled agents up-to-date on the state of 
            ICE processing.
          </t>
        </list>
      </t>
      <t>
        When conveying an end-of-candidates indication during trickling
        (rather than as a part of the initial ICE description or a response thereto), 
        it is the responsibility of the
        using protocol to define methods for associating the
        indication with one or more specific media streams.
      </t>
      <t>
        Receiving an end-of-candidates indication enables an agent to
        update check list states and, in case valid pairs do not exist
        for every component in every media stream, determine that ICE
        processing has failed. It also enables an agent to speed up the
        conclusion of ICE processing when a candidate pair has been validated
        but it involves the use of lower-preference transports such as
        TURN. In such situations, an implementation MAY choose to wait
        and see if higher-priority candidates are received; in this case
        the end-of-candidates indication provides a notification that such
        candidates are not forthcoming.
      </t>
      <t>
        An agent MAY also choose to generate an end-of-candidates
        indication before candidate gathering has actually completed, if the
        agent determines that gathering has continued for more than an
        acceptable period of time. However, an agent MUST NOT convey any
        more candidates after it has conveyed an end-of-candidates
        indication.
      </t>
      <t>
        When performing half trickle, an agent SHOULD convey an
        end-of-candidates indication together with its initial ICE description unless
        it is planning to potentially trickle additional candidates (e.g., in
        case the remote party turns out to support Trickle ICE).
      </t>
      <t>
        After an agent conveys the end-of-candidates indication, it will
        update the state of the corresponding check list as explained
        in <xref target="checks"/>. Past that point, an
        agent MUST NOT trickle any new candidates within this ICE session. 
        After an agent has received an end-of-candidates indication, it 
        MUST also ignore any newly received candidates for that media 
        stream or media session. Therefore, adding new candidates to the 
        negotiation is possible only through an ICE restart (see
        <xref target='subsequent'/>).
      </t>
      <t>
        This specification does not
        override regular ICE semantics for concluding ICE processing.
        Therefore, even if end-of-candidates indications are conveyed,
        an agent will still need to go through pair nomination. Also, if
        pairs have been nominated for components and media streams, ICE
        processing MAY still conclude even if end-of-candidates
        indications have not been received for all streams. In all cases,
        an agent MUST NOT trickle any new candidates within an ICE session
        after nomination of a candidate pair as described in Section 8.1.1
        of <xref target='rfc5245bis'/>. 
      </t>
      </section>
    </section>
    <section title='Receiving Additional Remote Candidates'
             anchor="recv-trickling">
      <t>
        At any time during ICE processing, a Trickle ICE agent might receive
        new candidates from the remote agent. When this happens and no
        local candidates are currently known for this same stream, the
        new remote candidates are added to the list of remote
        candidates.
      </t>
      <t>
        Otherwise, the new candidates are used for forming candidate
        pairs with the pool of local candidates and they are added to
        the local check lists as described in
        <xref target="cand-pairing"/>.
      </t>
      <t>
        Once the remote agent has completed candidate gathering, it
        will convey an end-of-candidates indication. Upon receiving such an
        indication, the local agent MUST update check list states as per
        <xref target="checks"/>. This might lead to some check
        lists being marked as Failed.
      </t>
    </section>
    <section title='Receiving an End-Of-Candidates Indication'
             anchor="end-of-candidates.recv">
      <t>
        When an agent receives an end-of-candidates indication
        for a specific media stream, it will update the state of the 
        relevant check list as per
        <xref target="checks"/>. If the check list is still 
        in the Active state after the update, the agent will persist 
        the fact that an end-of-candidates indication has been
        received and take it into account in future updates
        to the check list.
      </t>
    </section>
    <section title="Trickle ICE and Peer Reflexive Candidates">
      <t>
        Even though Trickle ICE does not explicitly modify the
        procedures for handling peer-reflexive candidates, use of Trickle ICE
        can have an impact on how they are processed. With Trickle
        ICE, it is possible that server reflexive candidates can be
        discovered as peer reflexive in cases where incoming
        connectivity checks are received from these candidates before
        the trickle updates that carry them.
      </t>
      <t>
        While this would certainly increase the number of cases where
        ICE processing nominates and selects candidates discovered as
        peer-reflexive, it does not require any change in processing.
      </t>
      <t>
        It is also likely that some applications would prefer not to
        trickle server reflexive candidates to entities that are known
        to be publicly accessible and where sending a direct STUN
        binding request is likely to reach the destination faster than
        the trickle update that travels through the signaling path.
      </t>
    </section>
    <section title='Subsequent Exchanges'
             anchor="subsequent">
      <t>
        Before conveying an end-of-candidates indication, 
        either agent MAY convey subsequent candidate information at any time allowed
        by the signaling protocol in use. When this happens, agents will use
        <xref target="rfc5245bis"/> semantics to determine whether or not
        the new candidate information require an ICE restart.  If an ICE restart
        occurs, the agents can assume that Trickle ICE is still supported
        if support was determined previously, and thus can engage in Trickle ICE 
        behavior as they would in an initial exchange of ICE descriptions where
        support was determined through a capabilities discovery method.
      </t>
    </section>
    <section title='Unilateral Use of Trickle ICE (Half Trickle)'
             anchor="half-trickle">
      <t>
        In half trickle mode, the initiator conveys the initial ICE description
        with a full generation of candidates. This ensures that the
        ICE description can be processed by a regular ICE responder and is mostly
        meant for use in cases where support for Trickle ICE cannot be 
        confirmed prior to conveying the initial ICE description.  The initial ICE description 
        indicate support for Trickle ICE, which means the responder can
        respond with something less than a full generation of candidates and then 
        trickle the rest.  The initial ICE description for half trickle would typically contain an
        end-of-candidates indication, although this is not mandatory
        because if trickle support is confirmed then the initiator can
        choose to trickle additional candidates before it conveys an
        end-of-candidates indication.
      </t>
      <t>
        The half trickle mechanism can be used in cases where there is
        no way for an agent to verify in advance whether a remote
        party supports Trickle ICE. Because the initial ICE description contain
        a full generation of candidates, it can thus be handled by a regular
        ICE agent, while still allowing a Trickle ICE agent to use
        the optimization defined in this specification. This prevents
        negotiation from failing in the former case while still giving
        roughly half the Trickle ICE benefits in the latter (hence the
        name of the mechanism).
      </t>
      <t>
        Use of half trickle is only necessary during an initial
        exchange of ICE descriptions. After both parties have received 
        an ICE description from their peer, they can each reliably
        determine Trickle ICE support and use it for all subsequent
        exchanges.
      </t>
      <t>
        In some instances, using half trickle might bring more than 
        just half the improvement in terms of user experience. This 
        can happen when an agent starts gathering candidates upon user 
        interface cues that the user will soon be initiating an interaction, 
        such as activity on a keypad or the phone going off hook. This 
        would mean that some or all of the candidate
        gathering could be completed before the agent actually
        needs to convey the candidate information. Because the responder will be able
        to trickle candidates, both agents will be able to start
        connectivity checks and complete ICE processing earlier than
        with regular ICE and potentially even as early as with full
        trickle.
      </t>
      <t>
        However, such anticipation is not always possible. For
        example, a multipurpose user agent or a WebRTC web page where
        communication is a non-central feature (e.g., calling a support
        line in case of a problem with the main features) would not
        necessarily have a way of distinguishing between call
        intentions and other user activity. In such cases, using full
        trickle is most likely to result in an ideal user experience.
        Even so, using half trickle would be an improvement over regular
        ICE because it would result in a better experience for responders.
      </t>
    </section>
    <section title='Requirements for Signaling Protocols' anchor="signal">
      <t>
        In order to fully enable the use of Trickle ICE, this specification
        defines the following requirements for signaling protocols.
        <list style='symbols'>
          <t>
            A signaling protocol SHOULD provide a way for parties to advertise 
            and discover support for Trickle ICE before an ICE 
            session begins (see <xref target='disco'/>).
          </t>
          <t>
            A signaling protocol MUST provide methods for incrementally
            conveying (i.e., "trickling") additional candidates after 
            conveying the initial ICE description (see 
            <xref target='send-trickling'/>).
          </t>
          <t>
            A signaling protocol MUST deliver each trickled candidate 
            or end-of-candidates indication not
            more than once and in the same order it was conveyed (see 
            <xref target='send-trickling'/>).
          </t>
          <t>
            A signaling protocol MUST provide a mechanism for both parties 
            to indicate and agree on the ICE session in force
            (see <xref target='send-trickling'/>).
          </t>
          <t>
            A signaling protocol MUST provide a way for parties to communicate the 
            end-of-candidates indication, which MUST specify the particular ICE 
            session to which the indication applies (see <xref target='end-of-candidates'/>).
          </t>
        </list>
      </t>
    </section>
    <section title='Preserving Candidate Order while Trickling'>
      <t>
        One important aspect of regular ICE is that connectivity checks
        for a specific foundation and component are attempted
        simultaneously by both agents, so that any firewalls or NATs
        fronting the agents would whitelist both endpoints and allow
        all except for the first ("suicide") packets to go through. This
        is also important to unfreezing candidates at the right time. While 
        not crucial, preserving this behavior in Trickle ICE is likely to 
        improve ICE performance.
      </t>
      <t>
        To achieve this, when trickling candidates, agents MUST respect the 
        order of components as reflected by their component IDs; that is,
        candidates for a given component 
        MUST NOT be conveyed prior to candidates for a component with a 
        lower ID number within the same foundation. In addition, candidates 
        MUST be paired, following the procedures in <xref target='cand-insert'/>, 
        in the same order they are conveyed.
      </t>
      <t>
        For example, the following SDP description contains two
        components (RTP and RTCP) and two foundations (host and 
        server reflexive):
        <figure>
          <artwork>
<![CDATA[
  v=0
  o=jdoe 2890844526 2890842807 IN IP6 2001:db8:a0b:12f0::1
  s=
  c=IN IP6 2001:db8:a0b:12f0::1
  t=0 0
  a=ice-pwd:asd88fgpdd777uzjYhagZg
  a=ice-ufrag:8hhY
  m=audio 5000 RTP/AVP 0
  a=rtpmap:0 PCMU/8000
  a=candidate:1 1 UDP 2130706431 2001:db8:a0b:12f0::1 5000 typ host
  a=candidate:1 2 UDP 2130706431 2001:db8:a0b:12f0::1 5001 typ host
  a=candidate:2 1 UDP 1694498815 2001:db8:a0b:12f0::3 5000 typ srflx
      raddr 2001:db8:a0b:12f0::1 rport 8998
  a=candidate:2 2 UDP 1694498815 2001:db8:a0b:12f0::3 5001 typ srflx
      raddr 2001:db8:a0b:12f0::1 rport 8998
]]>
          </artwork>
        </figure>
        For this candidate information the RTCP host candidate would not be conveyed
        prior to the RTP host candidate. Similarly the RTP server
        reflexive candidate would be conveyed together with or prior to the
        RTCP server reflexive candidate.
      </t>
      <t>
        Similar considerations apply at the level of media streams in addition
        to foundations; this is covered by the requirement to always start
        unfreezing candidates starting from the first media stream
        as described under <xref target="check.lists"/>.
      </t>
    </section>
    <section title='IANA Considerations'>
      <t>
        IANA is requested to register the following ICE option in the "ICE
        Options" sub-registry of the "Interactive Connectivity Establishment
        (ICE) registry", following the procedures defined in
        <xref target='RFC6336'/>.
      </t>
      <t>
        <list style='hanging'>
          <t hangText="ICE Option:">trickle</t>
          <t hangText="Contact:">IESG, iesg@ietf.org</t>
          <t hangText="Change control:">IESG</t>
          <t hangText="Description:">
            An ICE option of "trickle" indicates support for incremental
            communication of ICE candidates.
          </t>
          <t hangText="Reference:">RFC XXXX</t>
        </list>
      </t>
    </section>
    <section title='Security Considerations'>
      <t>
        This specification inherits most of its semantics from
        <xref target="rfc5245bis"/> and as a result all security
        considerations described there apply to Trickle ICE.
      </t>
      <t>
        If the privacy implications of revealing host addresses on an
        endpoint device are a concern (see for example the discussion
        in <xref target='I-D.ietf-rtcweb-ip-handling'/> and in Section 19
        of <xref target="rfc5245bis"/>), agents can generate ICE descriptions that contain no
        candidates and then only trickle candidates that do not reveal
        host addresses (e.g., relayed candidates).
      </t>
    </section>
    <section title='Acknowledgements'>
     <t>   
        The authors would like to thank Bernard Aboba, Flemming Andreasen, 
        Rajmohan Banavi, Taylor Brandstetter, Philipp Hancke, Christer Holmberg, Ari Keranen,
        Paul Kyzivat, Jonathan Lennox, Enrico Marocco, Pal Martinsen, Nils Ohlmeier, Thomas Stach,
        Peter Thatcher, Martin Thomson, Dale R. Worley, and Brandon Williams 
        for their reviews and suggestions on improving this document. Thanks also
        to Ari Keranen and Peter Thatcher in their role as chairs, and Ben Campbell
        in his role as responsible Area Director.
      </t>
    </section>
  </middle>
  <back>
    <references title='Normative References'>
      <?rfc include="reference.RFC.2119"?>

<reference anchor='rfc5245bis'>
<front>
<title>Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal</title>
<author initials='A' surname='Keranen' fullname='Ari Keranen'>
    <organization />
</author>
<author initials='C' surname='Holmberg' fullname='Christer Holmberg'>
    <organization />
</author>
<author initials='J' surname='Rosenberg' fullname='Jonathan Rosenberg'>
    <organization />
</author>
<date month='February' day='2' year='2018' />
<abstract><t>This document describes a protocol for Network Address Translator (NAT) traversal for UDP-based multimedia.  This protocol is called Interactive Connectivity Establishment (ICE).  ICE makes use of the Session Traversal Utilities for NAT (STUN) protocol and its extension, Traversal Using Relay NAT (TURN).  This document obsoletes RFC 5245.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-ice-rfc5245bis-17' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-ice-rfc5245bis-17.txt' />
</reference>

    </references>
    <references title='Informative References'>
      <?rfc include="reference.RFC.1918"?>
      <?rfc include="reference.RFC.3261"?>
      <?rfc include="reference.RFC.3264"?>
      <?rfc include="reference.RFC.4566"?>
      <?rfc include="reference.RFC.4787"?>
      <?rfc include="reference.RFC.5389"?>
      <?rfc include="reference.RFC.5766"?>
      <?rfc include="reference.RFC.6120"?>
      <?rfc include="reference.RFC.6336"?>
<reference anchor='I-D.ietf-mmusic-trickle-ice-sip'>
<front>
<title>A Session Initiation Protocol (SIP) usage for Trickle ICE</title>
<author initials='E' surname='Ivov' fullname='Emil Ivov'>
    <organization />
</author>
<author initials='T' surname='Stach' fullname='Thomas Stach'>
    <organization />
</author>
<author initials='E' surname='Marocco' fullname='Enrico Marocco'>
    <organization />
</author>
<author initials='C' surname='Holmberg' fullname='Christer Holmberg'>
    <organization />
</author>
<date month='February' day='24' year='2018' />
<abstract><t>The Interactive Connectivity Establishment (ICE) protocol describes a Network Address Translator (NAT) traversal mechanism for UDP-based multimedia sessions established with the Offer/Answer model.  The ICE extension for Incremental Provisioning of Candidates (Trickle ICE) defines a mechanism that allows ICE agents to shorten session establishment delays by making the candidate gathering and connectivity checking phases of ICE non-blocking and by executing them in parallel.  This document defines usage semantics for Trickle ICE with the Session Initiation Protocol (SIP).</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-mmusic-trickle-ice-sip-14' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-mmusic-trickle-ice-sip-14.txt' />
</reference>
<reference anchor='I-D.ietf-rtcweb-ip-handling'>
<front>
<title>WebRTC IP Address Handling Requirements</title>
<author initials='J' surname='Uberti' fullname='Justin Uberti'>
    <organization />
</author>
<author initials='G' surname='Shieh' fullname='Guo-wei Shieh'>
    <organization />
</author>
<date month='July' day='3' year='2017' />
<abstract><t>This document provides information and requirements for how IP addresses should be handled by WebRTC implementations.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-rtcweb-ip-handling-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-rtcweb-ip-handling-04.txt' />
</reference>
      <reference anchor="XEP-0176">
        <front>
          <title>XEP-0176: Jingle ICE-UDP Transport Method</title>
          <author initials='J.' surname='Beda' fullname='Joe Beda'>
                  <organization abbrev='Google'>Google</organization>
          </author>
          <author initials='S.' surname='Ludwig'
                  fullname='Scott Ludwig'>
            <organization abbrev='Google'>Google</organization>
          </author>
          <author initials='P.' surname='Saint-Andre'
                  fullname='Peter Saint-Andre'>
          </author>
          <author initials='J.' surname='Hildebrand'
                  fullname='Joe Hildebrand'>
            <organization abbrev='Cisco'>Cisco</organization>
          </author>
          <author initials='S.' surname='Egan' fullname='Sean Egan'>
            <organization abbrev='Google'>Google </organization>
          </author>
          <author initials='R.' surname='McQueen'
                      fullname='Robert McQueen'>
            <organization abbrev='Collabora'>Collabora</organization>
          </author>
          <date month="June" year="2009" />
        </front>
        <seriesInfo name="XEP" value="XEP-0176" />
      </reference>
      <reference anchor="XEP-0030">
        <front>
          <title>XEP-0030: Service Discovery</title>
          <author initials='J.' surname='Hildebrand'
                  fullname='Joe Hildebrand'>
            <organization abbrev='Cisco'>Cisco</organization>
          </author>
          <author initials='P.' surname='Millard'
                  fullname='Peter Millard'>
          </author>
          <author initials='R.' surname='Eatmon'
                  fullname='Ryan Eatmon'>
          </author>
          <author initials='P.' surname='Saint-Andre'
                  fullname='Peter Saint-Andre'>
          </author>
          <date month="June" year="2008" />
        </front>
        <seriesInfo name="XEP" value="XEP-0030" />
      </reference>
    </references>
    <section title='Interaction with Regular ICE'
             anchor='interaction'>
      <t>
        The ICE protocol was designed to be flexible enough to
        work in and adapt to as many network environments as
        possible. Despite that flexibility, ICE as specified in
        <xref target="rfc5245bis"/> does not by itself support trickle 
        ICE. This section describes how trickling of candidates 
        interacts with ICE.
      </t>
      <t>
        <xref target="rfc5245bis"/> describes the conditions required to
        update check lists and timer states while an ICE agent is in the
        Running state. These conditions are verified upon transaction
        completion and one of them stipulates that:
      </t>
      <t>
        <list style='empty'>
          <t>
            If there is not a pair in the valid list for each component
            of the media stream, the state of the check list is set to
            Failed.
          </t>
        </list>
      </t>
      <t>
        This could be a problem and cause ICE processing to fail
        prematurely in a number of scenarios. Consider the following
        case:
      </t>
      <t>
        <list style='numbers'>
          <t>
            Alice and Bob are both located in different networks with
            Network Address Translation (NAT). Alice and Bob themselves
            have different address but both networks use the same
            private internet block (e.g., the "20-bit block"
            172.16/12 specified in <xref target="RFC1918"/>).
          </t>
          <t>
            Alice conveys to Bob the candidate 172.16.0.1 which also happens
            to correspond to an existing host on Bob's network.
          </t>
          <t>
            Bob creates a check list consisting solely of 172.16.0.1 and
            starts checks.
          </t>
          <t>
            These checks reach the host at 172.16.0.1 in Bob's network,
            which responds with an ICMP "port unreachable" error; per
            <xref target="rfc5245bis"/> Bob marks the transaction as
            Failed.
          </t>
        </list>
        At this point the check list only contains Failed candidates and
        the valid list is empty. This causes the media stream and
        potentially all ICE processing to fail, even though if trickle agents
        could subsequently convey candidates that
        would cause previously empty check lists to become non-empty.
      </t>
      <t>
        A similar race condition would occur if the initial ICE description from
        Alice contain only candidates that can be determined as
        unreachable from
        any of the candidates that Bob has gathered (e.g., this would be the
        case if Bob's candidates only contain IPv4 addresses and the
        first candidate that he receives from Alice is an IPv6 one).
      </t>
      <t>
        Another potential problem could arise when a non-trickle
        ICE implementation initiates an interaction with a Trickle ICE 
        implementation. Consider the following case:
        <list style='numbers'>
          <t>
            Alice's client has a non-Trickle ICE implementation.
          </t>
          <t>
            Bob's client has support for Trickle ICE.
          </t>
          <t>
            Alice and Bob are behind NATs with address-dependent
            filtering <xref target="RFC4787"/>.
          </t>
          <t>
            Bob has two STUN servers but one of them is currently
            unreachable.
          </t>
        </list>
      </t>
      <t>
        After Bob's agent receives Alice's initial ICE description it would 
        immediately start connectivity checks. It would also start gathering
        candidates, which would take a long time because of the unreachable
        STUN server. By the time Bob's answer is ready and conveyed to
        Alice, Bob's connectivity checks may well have failed: until
        Alice gets Bob's answer, she won't be able to start connectivity
        checks and punch holes in her NAT. The NAT would hence be
        filtering Bob's checks as originating from an unknown endpoint.
      </t>
    </section>
    <section title='Interaction with ICE Lite'>
      <t>
        The behavior of ICE lite agents that are capable of Trickle ICE does not
        require any particular rules other than those already defined
        in this specification and <xref target="rfc5245bis"/>. This section
        is hence provided only for informational purposes.
      </t>
      <t>
        An ICE lite agent would generate candidate information 
        as per <xref target="rfc5245bis"/> and 
        would indicate support for Trickle ICE. Given
        that the candidate information will contain a full generation of candidates,
        it would also be accompanied by an end-of-candidates indication.
      </t>
      <t>
        When performing full trickle, a full ICE implementation could
        convey the initial ICE description or response thereto with no candidates. After receiving 
        a response that
        identifies the remote agent as an ICE lite implementation, the
        initiator can choose to not trickle any additional
        candidates. The same is also true in the case when the ICE lite
        agent initiates the interaction and the full ICE agent is the responder. In
        these cases the connectivity checks would be enough for the ICE
        lite implementation to discover all potentially useful
        candidates as peer reflexive. The following example illustrates
        one such ICE session using SDP syntax:
      </t>
      <figure title="Example " anchor="fig-ice-lite">
        <artwork>
<![CDATA[
        ICE Lite                                          Bob
         Agent
           |   Offer (a=ice-lite a=ice-options:trickle)    |
           |---------------------------------------------->|
           |                                               |no cand
           |         Answer (a=ice-options:trickle)        |trickling
           |<----------------------------------------------|
           |              Connectivity Checks              |
           |<--------------------------------------------->|
  peer rflx|                                               |
 cand disco|                                               |
           |                                               |
           |<=============== MEDIA FLOWS =================>|

]]>
        </artwork>
      </figure>
      <t>
        In addition to reducing signaling traffic this approach also
        removes the need to discover STUN bindings or make TURN 
        allocations, which may considerably lighten ICE processing.
      </t>
    </section>
    <section title='Changes from Earlier Versions'>
      <t>
        Note to the RFC Editor: please remove this section prior to
        publication as an RFC.
      </t>
      <section title='Changes from draft-ietf-ice-trickle-17'>
        <t>
          <list style='symbols'>
            <t>
              Clarified it is not allowed to nominate a candidate 
              pair after a pair has already been nominated (a.k.a. 
              renomination or continuous nomination).
            </t>
            <t>
              Removed some text that referenced older versions of
              rfc5245bis.
            </t>
            <t>
              Removed some text that duplicated concepts and procedures 
              specified in rfc5245bis.
            </t>
            <t>
              Removed the ill-defined concept of stream order.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ietf-ice-trickle-16'>
        <t>
          <list style='symbols'>
            <t>
              Made "ufrag" terminology consistent with 5245bis.
            </t>
            <t>
              Applied in-order delivery rule to end-of-candidates indication.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ietf-ice-trickle-15'>
        <t>
          <list style='symbols'>
            <t>
              Adjustments to address AD review feedback.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ietf-ice-trickle-14'>
        <t>
          <list style='symbols'>
            <t>
              Minor modifications to track changes to ICE core.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ietf-ice-trickle-13'>
        <t>
          <list style='symbols'>
            <t>
              Removed independent monitoring of check list "states" of
              frozen or active, since this is handled by placing a check
              list in the Running state defined in ICE core.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ietf-ice-trickle-12'>
        <t>
          <list style='symbols'>
            <t>
              Specified that the end-of-candidates indication must
              include the generation (ufrag/pwd) to enable association
              with a particular ICE session.
            </t>
            <t>
              Further editorial fixes to address WGLC feedback.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ietf-ice-trickle-11'>
        <t>
          <list style='symbols'>
            <t>
              Editorial and terminological fixes to address WGLC feedback.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ietf-ice-trickle-10'>
        <t>
          <list style='symbols'>
            <t>
              Minor editorial fixes.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ietf-ice-trickle-09'>
        <t>
          <list style='symbols'>
            <t>
              Removed immediate unfreeze upon Fail.
            </t>
            <t>
              Specified MUST NOT regarding ice-options.
            </t>
            <t>
              Changed terminology regarding initial ICE parameters
              to avoid implementer confusion.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ietf-ice-trickle-08'>
        <t>
          <list style='symbols'>
            <t>
              Reinstated text about in-order processing of messages
              as a requirement for signaling protocols.
            </t>
            <t>
              Added IANA registration template for ICE option.
            </t>
            <t>
              Corrected Case 3 rule in Section 8.1.1 to ensure
              consistency with regular ICE rules.
            </t>
            <t>
              Added tabular representations to Section 8.1.1 in order
              to illustrate the new pair rules.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ietf-ice-trickle-07'>
        <t>
          <list style='symbols'>
            <t>
              Changed "ICE description" to "candidate information" for 
              consistency with 5245bis.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ietf-ice-trickle-06'>
        <t>
          <list style='symbols'>
            <t>
              Addressed editorial feedback from chairs' review.
            </t>
            <t>
              Clarified terminology regarding generations.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ietf-ice-trickle-05'>
        <t>
          <list style='symbols'>
            <t>
              Rewrote the text on inserting a new pair into a 
              check list.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ietf-ice-trickle-04'>
        <t>
          <list style='symbols'>
            <t>
              Removed dependency on SDP and offer/answer model.
            </t>
            <t>
              Removed mentions of aggressive nomination, since it is
              deprecated in 5245bis.
            </t>
            <t>
              Added section on requirements for signaling protocols.
            </t>
            <t>
              Clarified terminology.
            </t>
            <t>
              Addressed various WG feedback.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ietf-ice-trickle-03'>
        <t>
          <list style='symbols'>
            <t>
              Provided more detailed description of unfreezing behavior, specifically
              how to replace pre-existing peer-reflexive candidates with higher-priority 
              ones received via trickling.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ietf-ice-trickle-02'>
        <t>
          <list style='symbols'>
            <t>
              Adjusted unfreezing behavior when there are disparate foundations.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ietf-ice-trickle-01'>
        <t>
          <list style='symbols'>
            <t>
              Changed examples to use IPv6.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ietf-ice-trickle-00'>
        <t>
          <list style='symbols'>
            <t>
              Removed dependency on SDP (which is to be provided 
              in a separate specification).
            </t>
            <t>
              Clarified text about the fact that a check list
              can be empty if no candidates have been sent or
              received yet.
            </t>
            <t>
              Clarified wording about check list states so as not
              to define new states for "Active" and "Frozen" because
              those states are not defined for check lists (only for
              candidate pairs) in ICE core.
            </t>
            <t>
              Removed open issues list because it was out of date.
            </t>
            <t>
              Completed a thorough copy edit.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-mmusic-trickle-ice-02'>
        <t>
          <list style='symbols'>
            <t>
              Addressed feedback from Rajmohan Banavi and Brandon Williams.
            </t>
            <t>
              Clarified text about determining support and about how to 
              proceed if it can be determined that the answering agent
              does not support Trickle ICE.
            </t>
            <t>
              Clarified text about check list and timer updates.
            </t>
            <t>
              Clarified when it is appropriate to use half trickle or
              to send no candidates in an offer or answer.
            </t>
            <t>
              Updated the list of open issues.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ivov-01 and draft-mmusic-00'>
        <t>
          <list style='symbols'>
            <t>
              Added a requirement to trickle candidates by order of
              components to avoid deadlocks in the unfreezing algorithm.
            </t>
            <t>
              Added an informative note on peer-reflexive candidates
              explaining that nothing changes for them semantically but
              they do become a more likely occurrence for Trickle ICE.
            </t>
            <t>
              Limit the number of pairs to 100 to comply with 5245.
            </t>
            <t>
              Added clarifications on the non-importance of how newly
              discovered candidates are trickled/sent to the remote
              party or if this is done at all.
            </t>
            <t>
              Added transport expectations for trickled candidates
              as per Dale Worley's recommendation.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-ivov-00'>
        <t>
          <list style='symbols'>
            <t>
              Specified that end-of-candidates is a media level
              attribute which can of course appear as session level,
              which is equivalent to having it appear in all m-lines.
              Also made end-of-candidates optional for cases such as
              aggressive nomination for controlled agents.
            </t>
            <t>
              Added an example for ICE lite and Trickle ICE to
              illustrate how, when talking to an ICE lite agent doesn't
              need to send or even discover any candidates.
            </t>
            <t>
              Added an example for ICE lite and Trickle ICE to
              illustrate how, when talking to an ICE lite agent doesn't
              need to send or even discover any candidates.
            </t>
            <t>
              Added wording that explicitly states ICE lite agents
              have to be prepared to receive no candidates over
              signaling and that they should not freak out if this
              happens. (Closed the corresponding open issue).
            </t>
            <t>
              It is now mandatory to use MID when trickling candidates
              and using m-line indexes is no longer allowed.
            </t>
            <t>
              Replaced use of 0.0.0.0 to IP6 :: in order to avoid
              potential issues with RFC2543 SDP libraries that interpret
              0.0.0.0 as an on-hold operation. Also changed the port
              number here from 1 to 9 since it already has a more
              appropriate meaning. (Port change suggested by Jonathan
              Lennox).
            </t>
            <t>
              Closed the Open Issue about use about what to do with
              cands received after end-of-cands. Solution: ignore, do
              an ICE restart if you want to add something.
            </t>
            <t>
              Added more terminology, including trickling, trickled
              candidates, half trickle, full trickle,
            </t>
            <t>
              Added a reference to the SIP usage for Trickle ICE as
              requested at the Boston interim.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-rescorla-01'>
        <t>
          <list style='symbols'>
            <t>
              Brought back explicit use of Offer/Answer. There are no
              more attempts to try to do this in an O/A independent way.
              Also removed the use of ICE Descriptions.
            </t>
            <t>
              Added SDP specification for trickled candidates, the
              trickle option and 0.0.0.0 addresses in m-lines, and
              end-of-candidates.
            </t>
            <t>
              Support and Discovery. Changed that section to be less
              abstract. As discussed in IETF85, the draft now says
              implementations and usages need to either determine
              support in advance and directly use trickle, or do
              half trickle. Removed suggestion about use of discovery in
              SIP or about letting implementing protocols do what they
              want.
            </t>
            <t>
              Defined Half Trickle. Added a section that says how it
              works. Mentioned that it only needs to happen in the first
              o/a (not necessary in updates), and added Jonathan's
              comment about how it could, in some cases, offer more than
              half the improvement if you can pre-gather part or all of
              your candidates before the user actually presses the call
              button.
            </t>
            <t>
              Added a short section about subsequent offer/answer
              exchanges.
            </t>
            <t>
              Added a short section about interactions with ICE Lite
              implementations.
            </t>
            <t>
              Added two new entries to the open issues section.
            </t>
          </list>
        </t>
      </section>
      <section title='Changes from draft-rescorla-00'>
        <t>
          <list style='symbols'>
            <t>
              Relaxed requirements about verifying support following
              a discussion on MMUSIC.
            </t>
            <t>
              Introduced ICE descriptions in order to remove ambiguous
              use of 3264 language and inappropriate references to
              offers and answers.
            </t>
            <t>
              Removed inappropriate assumption of adoption by RTCWEB
              pointed out by Martin Thomson.
            </t>
          </list>
        </t>
      </section>
    </section>
  </back>
</rfc>
